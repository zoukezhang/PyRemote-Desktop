<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remote Desktop Client</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #222; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        #screen-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
        }
        #screen { 
            cursor: none; 
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        
        /* Floating Toolbar */
        #toolbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(40, 40, 40, 0.9);
            padding: 10px 20px;
            border-radius: 12px;
            display: flex;
            gap: 10px;
            align-items: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.1);
            transition: opacity 0.3s;
            opacity: 0.2; /* Fade out when idle */
        }
        #toolbar:hover {
            opacity: 1;
        }
        
        input[type="text"] {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            outline: none;
            width: 200px;
        }
        input[type="text"]:focus {
            border-color: #007AFF;
            background: rgba(255,255,255,0.15);
        }
        
        button {
            background: #444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #555;
        }
        button:active {
            background: #333;
        }
        button.primary {
            background: #007AFF;
        }
        button.primary:hover {
            background: #0062CC;
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff3b30; /* Red = Offline */
            margin-right: 10px;
        }
        .status-indicator.connected {
            background: #34c759; /* Green = Online */
            box-shadow: 0 0 8px #34c759;
        }
        
        .divider {
            width: 1px;
            height: 24px;
            background: rgba(255,255,255,0.2);
            margin: 0 5px;
        }
    </style>
</head>
<body>
    <div id="screen-container">
        <img id="screen" src="" alt="Waiting for connection...">
    </div>

    <div id="toolbar">
        <div id="status" class="status-indicator" title="Disconnected"></div>
        
        <input type="text" id="remote-input" placeholder="Type text to send..." onkeydown="if(event.key==='Enter') sendText()">
        <button onclick="sendText()" class="primary">Send Type</button>
        
        <div class="divider"></div>
        
        <button onclick="sendClipboard()" title="Send local clipboard to remote">Send Clip</button>
        <button onclick="getClipboard()" title="Get remote clipboard to local">Get Clip</button>
    </div>

    <script>
        const img = document.getElementById('screen');
        const statusEl = document.getElementById('status');
        const ws = new WebSocket(`ws://${location.host}/ws`);

        ws.onopen = () => {
            console.log('Connected');
            statusEl.classList.add('connected');
            statusEl.title = "Connected";
        };

        ws.onmessage = async (event) => {
            const msg = JSON.parse(event.data);
            
            if (msg.type === 'frame') {
                img.src = 'data:image/jpeg;base64,' + msg.data;
            } else if (msg.type === 'clipboard_text') {
                try {
                    await navigator.clipboard.writeText(msg.text);
                    alert('Remote clipboard copied to local!');
                } catch (err) {
                    console.error('Failed to write clipboard: ', err);
                    alert('Failed to copy to clipboard. Browser permission denied?');
                }
            }
        };

        ws.onclose = () => {
            console.log('Disconnected');
            statusEl.classList.remove('connected');
            statusEl.title = "Disconnected";
        };

        // --- Features ---

        function sendText() {
            const input = document.getElementById('remote-input');
            const text = input.value;
            if (!text) return;
            
            ws.send(JSON.stringify({ action: 'type_text', text: text }));
            input.value = ''; // Clear input
        }

        async function sendClipboard() {
            try {
                const text = await navigator.clipboard.readText();
                ws.send(JSON.stringify({ action: 'clipboard_set', text: text }));
                // alert('Local clipboard sent to remote!'); // Optional feedback
            } catch (err) {
                console.error('Failed to read clipboard: ', err);
                alert('Failed to read local clipboard. Please allow clipboard access.');
            }
        }

        function getClipboard() {
            ws.send(JSON.stringify({ action: 'clipboard_get' }));
        }

        // --- Input Handling ---
        
        function getCoords(e) {
            const rect = img.getBoundingClientRect();
            const scaleX = img.naturalWidth / rect.width;
            const scaleY = img.naturalHeight / rect.height;
            return {
                x: Math.round((e.clientX - rect.left) * scaleX),
                y: Math.round((e.clientY - rect.top) * scaleY)
            };
        }

        let lastMove = 0;
        img.addEventListener('mousemove', (e) => {
            const now = Date.now();
            if (now - lastMove < 30) return; 
            lastMove = now;
            
            const { x, y } = getCoords(e);
            ws.send(JSON.stringify({ action: 'mousemove', x, y }));
        });

        img.addEventListener('mousedown', (e) => {
            const { x, y } = getCoords(e);
            ws.send(JSON.stringify({ action: 'mousemove', x, y }));
            
            let button = 'left';
            if (e.button === 2) button = 'right';
            if (e.button === 1) button = 'middle';
            ws.send(JSON.stringify({ action: 'mousedown', button }));
        });

        img.addEventListener('mouseup', (e) => {
            let button = 'left';
            if (e.button === 2) button = 'right';
            if (e.button === 1) button = 'middle';
            ws.send(JSON.stringify({ action: 'mouseup', button }));
        });

        img.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('keydown', (e) => {
            // Ignore if typing in the input box
            if (document.activeElement.tagName === 'INPUT') return;

            let key = e.key;
            // Map keys for PyAutoGUI
            if (key === 'ArrowUp') key = 'up';
            if (key === 'ArrowDown') key = 'down';
            if (key === 'ArrowLeft') key = 'left';
            if (key === 'ArrowRight') key = 'right';
            if (key === 'Control') key = 'ctrl'; // Mac: Ctrl is Ctrl
            if (key === 'Meta') key = 'command'; // Mac: Command
            if (key === 'Alt') key = 'alt';
            if (key === 'Shift') key = 'shift';
            if (key === 'Escape') key = 'esc';
            if (key === 'Enter') key = 'enter';
            if (key === 'Backspace') key = 'backspace';
            if (key === 'Tab') key = 'tab';
            
            // Only send if not a modifier-only press? No, send everything.
            ws.send(JSON.stringify({ action: 'keydown', key: key.toLowerCase() }));
            
            // Prevent default browser actions for some keys
            if (['Tab', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space'].includes(e.key)) {
                e.preventDefault();
            }
            // Prevent Ctrl+S, Ctrl+P etc if possible
            if ((e.ctrlKey || e.metaKey) && ['s', 'p', 'f'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (document.activeElement.tagName === 'INPUT') return;
            
            let key = e.key;
            if (key === 'ArrowUp') key = 'up';
            if (key === 'ArrowDown') key = 'down';
            if (key === 'ArrowLeft') key = 'left';
            if (key === 'ArrowRight') key = 'right';
            if (key === 'Control') key = 'ctrl';
            if (key === 'Meta') key = 'command';
            if (key === 'Alt') key = 'alt';
            if (key === 'Shift') key = 'shift';
            if (key === 'Escape') key = 'esc';
            if (key === 'Enter') key = 'enter';
            if (key === 'Backspace') key = 'backspace';
            if (key === 'Tab') key = 'tab';

            ws.send(JSON.stringify({ action: 'keyup', key: key.toLowerCase() }));
        });
        
        window.addEventListener('wheel', (e) => {
             ws.send(JSON.stringify({ action: 'scroll', dy: -e.deltaY }));
        }, { passive: true });

    </script>
</body>
</html>
